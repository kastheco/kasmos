package overlay

import (
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

var pickerBorderStyle = lipgloss.NewStyle().
	Border(lipgloss.RoundedBorder()).
	BorderForeground(colorIris).
	Padding(1, 2)

var pickerTitleStyle = lipgloss.NewStyle().
	Bold(true).
	Foreground(colorIris).
	MarginBottom(1)

var pickerSearchActiveStyle = lipgloss.NewStyle().
	Border(lipgloss.RoundedBorder()).
	BorderForeground(colorFoam).
	Padding(0, 1).
	MarginBottom(1)

var pickerItemStyle = lipgloss.NewStyle().
	Padding(0, 1).
	Foreground(colorText)

var pickerSelectedItemStyle = lipgloss.NewStyle().
	Padding(0, 1).
	Background(colorFoam).
	Foreground(colorBase)

var pickerHintStyle = lipgloss.NewStyle().
	Foreground(colorMuted).
	MarginTop(1)

// PickerOverlay shows a searchable list of options for selection.
type PickerOverlay struct {
	title       string
	allItems    []string
	filtered    []string
	selectedIdx int
	searchQuery string
	width       int
	submitted   bool
	cancelled   bool
	allowCustom bool // when true, typing a non-matching query offers "Create: <query>"
}

// NewPickerOverlay creates a picker with a title and list of items.
func NewPickerOverlay(title string, items []string) *PickerOverlay {
	filtered := make([]string, len(items))
	copy(filtered, items)
	return &PickerOverlay{
		title:    title,
		allItems: items,
		filtered: filtered,
		width:    40,
	}
}

// SetAllowCustom enables free-text entry when the search query doesn't match any item.
func (p *PickerOverlay) SetAllowCustom(allow bool) {
	p.allowCustom = allow
}

// HandleKeyPress processes input. Returns true when the overlay should close.
func (p *PickerOverlay) HandleKeyPress(msg tea.KeyMsg) bool {
	switch msg.String() {
	case "esc":
		p.cancelled = true
		return true
	case "enter":
		p.submitted = true
		return true
	case "up", "shift+tab":
		if p.selectedIdx > 0 {
			p.selectedIdx--
		}
	case "down", "tab":
		if p.selectedIdx < len(p.filtered)-1 {
			p.selectedIdx++
		}
	case "backspace":
		if len(p.searchQuery) > 0 {
			runes := []rune(p.searchQuery)
			p.searchQuery = string(runes[:len(runes)-1])
			p.applyFilter()
		}
	default:
		if msg.Type == tea.KeyRunes {
			p.searchQuery += string(msg.Runes)
			p.applyFilter()
		}
	}
	return false
}

const customPrefix = "+ Create: "

func (p *PickerOverlay) applyFilter() {
	if p.searchQuery == "" {
		p.filtered = make([]string, len(p.allItems))
		copy(p.filtered, p.allItems)
	} else {
		query := strings.ToLower(p.searchQuery)
		p.filtered = nil
		for _, item := range p.allItems {
			if strings.Contains(strings.ToLower(item), query) {
				p.filtered = append(p.filtered, item)
			}
		}
		// When allowCustom is on and query doesn't exactly match an existing item,
		// offer to create a new entry with the raw query text.
		if p.allowCustom && !p.hasExactMatch() {
			p.filtered = append(p.filtered, customPrefix+p.searchQuery)
		}
	}
	if p.selectedIdx >= len(p.filtered) {
		p.selectedIdx = len(p.filtered) - 1
	}
	if p.selectedIdx < 0 {
		p.selectedIdx = 0
	}
}

// hasExactMatch returns true if any item matches the search query exactly (case-insensitive).
func (p *PickerOverlay) hasExactMatch() bool {
	query := strings.ToLower(p.searchQuery)
	for _, item := range p.allItems {
		if strings.ToLower(item) == query {
			return true
		}
	}
	return false
}

// Value returns the selected item, or empty string if cancelled or nothing selected.
// When a custom "Create: <name>" entry is selected, returns just the name.
func (p *PickerOverlay) Value() string {
	if p.cancelled || len(p.filtered) == 0 {
		return ""
	}
	val := p.filtered[p.selectedIdx]
	if strings.HasPrefix(val, customPrefix) {
		return strings.TrimPrefix(val, customPrefix)
	}
	return val
}

// IsSubmitted returns true if the user pressed Enter.
func (p *PickerOverlay) IsSubmitted() bool {
	return p.submitted
}

// Render draws the picker overlay.
func (p *PickerOverlay) Render() string {
	var b strings.Builder

	// Title
	b.WriteString(pickerTitleStyle.Render(p.title))
	b.WriteString("\n")

	// Search bar
	innerWidth := p.width - 8 // borders + padding
	if innerWidth < 10 {
		innerWidth = 10
	}
	searchText := p.searchQuery
	if searchText == "" {
		searchText = "\uf002 Type to filter..."
	}
	b.WriteString(pickerSearchActiveStyle.Width(innerWidth).Render(searchText))
	b.WriteString("\n")

	// Items
	if len(p.filtered) == 0 {
		b.WriteString(pickerHintStyle.Render("  No matches"))
		b.WriteString("\n")
	} else {
		for i, item := range p.filtered {
			if i == p.selectedIdx {
				b.WriteString(pickerSelectedItemStyle.Width(innerWidth).Render("▸ " + item))
			} else {
				b.WriteString(pickerItemStyle.Width(innerWidth).Render("  " + item))
			}
			b.WriteString("\n")
		}
	}

	// Hint
	b.WriteString(pickerHintStyle.Render("↑↓ navigate • enter select • esc cancel"))

	return pickerBorderStyle.Width(p.width).Render(b.String())
}

func (p *PickerOverlay) SetSize(width, height int) {
	p.width = width
}
