package overlay

import (
	"fmt"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

// PermissionChoice mirrors tmux.PermissionChoice to avoid import cycle.
// Ordering matches opencode's left-to-right menu navigation and tmux.PermissionChoice,
// so app_input.go can cast directly without a mapping switch.
type PermissionChoice int

const (
	PermissionAllowOnce   PermissionChoice = iota // 0 — opencode's default cursor position
	PermissionAllowAlways                         // 1 — one Right arrow from default
	PermissionReject                              // 2 — two Right arrows from default
)

var permissionChoiceLabels = []string{"allow once", "allow always", "reject"}

// PermissionOverlay shows a three-choice modal for opencode permission prompts.
type PermissionOverlay struct {
	instanceTitle string
	description   string
	pattern       string
	selectedIdx   int
	confirmed     bool
	width         int
}

// NewPermissionOverlay creates a permission overlay with extracted prompt data.
func NewPermissionOverlay(instanceTitle, description, pattern string) *PermissionOverlay {
	return &PermissionOverlay{
		instanceTitle: instanceTitle,
		description:   description,
		pattern:       pattern,
		selectedIdx:   0, // default to "allow once" (opencode's default cursor position)
		width:         50,
	}
}

// HandleKeyPress processes input. Returns true when the overlay should close.
func (p *PermissionOverlay) HandleKeyPress(msg tea.KeyMsg) bool {
	switch msg.String() {
	case "left":
		if p.selectedIdx > 0 {
			p.selectedIdx--
		}
	case "right":
		if p.selectedIdx < len(permissionChoiceLabels)-1 {
			p.selectedIdx++
		}
	case "enter":
		p.confirmed = true
		return true
	case "esc":
		return true
	}
	return false
}

// Choice returns the selected permission choice.
func (p *PermissionOverlay) Choice() PermissionChoice {
	return PermissionChoice(p.selectedIdx)
}

// IsConfirmed returns true if the user pressed Enter.
func (p *PermissionOverlay) IsConfirmed() bool {
	return p.confirmed
}

// Pattern returns the permission pattern string extracted from the agent pane.
// Use this on confirm instead of re-parsing CachedContent, which may have changed.
func (p *PermissionOverlay) Pattern() string {
	return p.pattern
}

// Description returns the permission description shown in the overlay.
func (p *PermissionOverlay) Description() string {
	return p.description
}

// Render draws the permission overlay.
func (p *PermissionOverlay) Render() string {
	borderStyle := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(colorGold).
		Padding(1, 2).
		Width(p.width)

	titleStyle := lipgloss.NewStyle().
		Bold(true).
		Foreground(colorGold)

	descStyle := lipgloss.NewStyle().
		Foreground(colorText)

	patternStyle := lipgloss.NewStyle().
		Foreground(colorMuted)

	hintStyle := lipgloss.NewStyle().
		Foreground(colorMuted)

	selectedStyle := lipgloss.NewStyle().
		Background(colorFoam).
		Foreground(colorBase).
		Padding(0, 1)

	normalStyle := lipgloss.NewStyle().
		Foreground(colorText).
		Padding(0, 1)

	var b strings.Builder
	b.WriteString(titleStyle.Render("△ permission required"))
	b.WriteString("\n")
	b.WriteString(descStyle.Render(p.description))
	if p.pattern != "" {
		b.WriteString("\n")
		b.WriteString(patternStyle.Render(fmt.Sprintf("pattern: %s", p.pattern)))
	}
	if p.instanceTitle != "" {
		b.WriteString("\n")
		b.WriteString(patternStyle.Render(fmt.Sprintf("instance: %s", p.instanceTitle)))
	}
	b.WriteString("\n\n")

	// Render choices horizontally
	var choices []string
	for i, label := range permissionChoiceLabels {
		if i == p.selectedIdx {
			choices = append(choices, selectedStyle.Render("▸ "+label))
		} else {
			choices = append(choices, normalStyle.Render("  "+label))
		}
	}
	b.WriteString(lipgloss.JoinHorizontal(lipgloss.Center, choices...))
	b.WriteString("\n\n")
	b.WriteString(hintStyle.Render("←→ select · enter confirm · esc dismiss"))

	return borderStyle.Render(b.String())
}

// SetWidth sets the overlay width.
func (p *PermissionOverlay) SetWidth(w int) {
	p.width = w
}
